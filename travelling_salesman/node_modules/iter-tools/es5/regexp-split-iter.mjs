import _regeneratorRuntime from "@babel/runtime/regenerator";
import _getIterator from "@babel/runtime/core-js/get-iterator";

var _marked =
/*#__PURE__*/
_regeneratorRuntime.mark(regexpSplitIter);

import regexSplit from './regexp-split';

function regexpSplitIter(re, iterable) {
  var buffer, queue, mergeEmpty, _iterator, _isArray, _i, _ref, chunk, _iterator2, _isArray2, _i2, _ref2, strIter;

  return _regeneratorRuntime.wrap(function regexpSplitIter$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          buffer = '';
          mergeEmpty = false;
          _iterator = iterable, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);

        case 3:
          if (!_isArray) {
            _context.next = 9;
            break;
          }

          if (!(_i >= _iterator.length)) {
            _context.next = 6;
            break;
          }

          return _context.abrupt("break", 44);

        case 6:
          _ref = _iterator[_i++];
          _context.next = 13;
          break;

        case 9:
          _i = _iterator.next();

          if (!_i.done) {
            _context.next = 12;
            break;
          }

          return _context.abrupt("break", 44);

        case 12:
          _ref = _i.value;

        case 13:
          chunk = _ref;

          if (!(chunk === '')) {
            _context.next = 16;
            break;
          }

          return _context.abrupt("continue", 42);

        case 16:
          queue = [];
          buffer += chunk;
          _iterator2 = regexSplit(re, buffer), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);

        case 19:
          if (!_isArray2) {
            _context.next = 25;
            break;
          }

          if (!(_i2 >= _iterator2.length)) {
            _context.next = 22;
            break;
          }

          return _context.abrupt("break", 40);

        case 22:
          _ref2 = _iterator2[_i2++];
          _context.next = 29;
          break;

        case 25:
          _i2 = _iterator2.next();

          if (!_i2.done) {
            _context.next = 28;
            break;
          }

          return _context.abrupt("break", 40);

        case 28:
          _ref2 = _i2.value;

        case 29:
          strIter = _ref2;

          if (!(mergeEmpty && strIter === '')) {
            _context.next = 33;
            break;
          }

          mergeEmpty = false;
          return _context.abrupt("continue", 38);

        case 33:
          mergeEmpty = false;
          queue.push(strIter);

          if (!(queue.length === 2)) {
            _context.next = 38;
            break;
          }

          _context.next = 38;
          return queue.shift();

        case 38:
          _context.next = 19;
          break;

        case 40:
          mergeEmpty = queue[queue.length - 1] === '';
          buffer = queue.join('');

        case 42:
          _context.next = 3;
          break;

        case 44:
          if (!(queue && queue.length)) {
            _context.next = 46;
            break;
          }

          return _context.delegateYield(queue, "t0", 46);

        case 46:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

export default function curriedRegexpSplitIter(re, iterable) {
  if (typeof iterable === 'undefined') {
    return function (iterable) {
      return regexpSplitIter(re, iterable);
    };
  }

  return regexpSplitIter(re, iterable);
}